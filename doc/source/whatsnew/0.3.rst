What's New in kwant 0.3
=======================

This article explains the user-visible changes in kwant 0.3.


``possible_hoppings`` replaced by `~kwant.builder.HoppingKind`
--------------------------------------------------------------
The `~kwant.builder.Builder` method ``possible_hoppings`` has been rendered
obsolete.  Where previously one would have had ::

    for kind in lat.nearest:
        sys[sys.possible_hoppings(*kind)] = t

now it suffices to write ::

    sys[lat.nearest] = t

This is possible because `~kwant.builder.Builder` now accepts *functions* as
keys in addition to `~kwant.builder.Site` objects and tuples of them
(hoppings).  These functions are expected to yield either sites or hoppings,
when given a builder instance as the sole argument. The use of such keys is to
implement sets of sites or hoppings that depend on what is already present in
the builder, such as `~kwant.builder.HoppingKind`.  In the above example,
``lat.nearest`` is a list of ``HoppingKind`` objects.

Some renames
------------
* ``wave_func`` has been renamed to `~kwant.solvers.default.wave_function`,
* ``MonatomicLattice`` has been renamed to `~kwant.lattice.Monatomic`,
* ``PolyatomicLattice`` has been renamed to `~kwant.lattice.Polyatomic`.

Band structure plots
--------------------
A convenience function `~kwant.plotter.bands` for quick plotting of band
structure was implemented.

Immutable site groups
---------------------
In order to make naming more consistent, `kwant.make_lattice` was renamed and
can be found now as `~kwant.lattice.general`. Classes `Chain`, `Square`, and
`Honeycomb` from `~kwant.lattice` were made functions `~kwant.lattice.chain`,
`~kwant.lattice.square`, and `~kwant.lattice.honeycomb`.

In previous versions if one executed `a = kwant.lattice.square();
b = kwant.lattice.square()` then `a` and `b` were
actually different lattices. This often led to confusions in more convoluted
use cases, so this behavior was changed. Now two site groups created with the
same parameters are actually indistinguishable by `kwant`. If it is desired to
make two site groups which have the same geometry, but mean different things,
as for instance in :doc:`../tutorial/tutorial5`, then the `name` argument has
to be used when creating a lattice, e.g. `a = kwant.lattice.square(name='a');
b = kwant.lattice.square(name='b')`.

Parameters to Hamiltonian
-------------------------
kwant now allows the Hamiltonian matrix elements to be described with functions
that depend on an arbitrary number of parameters in addition to the sites on
which they are defined.

Previously, functions defining the Hamiltonian matrix elements had to have the
following prototypes::

    def onsite(site):
        ...

    def hopping(site1, site2):
        ...

If the Hamiltonian elements need to depend on some other external parameters
(e.g. magnetic field) then those had to be provided by some other means than
regular function parameters (e.g. global variables).

Now the value functions may accept arbitrary arguments after the `Site`
arguments.  These extra arguments can be specified when
`~kwant.solvers.default.solve` is called by setting the keyword arguments:

args
    A tuple of values to be passed as the positional arguments to the
    Hamiltonian value functions (not including the `Site` arguments).

kwargs
    A dictionary of keyword-value pairs to be passed as the keyword
    arguments to the Hamiltonian value functions.

For example, if the hopping and onsite Hamiltonian value functions have
the following prototype::

    def onsite(site, t, B, pot):
        ...

    def hopping(site1, site2, t, B, pot):
        ...

then the values of `t`, `B` and `pot` for which to solve the system can be
passed to `solve` like this::

    time = 2
    magnetic_field = 3
    potential = 4
    kwant.solve(sys, energy,
                args=(time,), kwargs={'B': magnetic_field, 'pot': potential})

Arguments can be passed in an equivalent way in calls to
`~kwant.solvers.default.wave_function` and `~kwant.solvers.default.ldos`.
