What's New in kwant 0.3
=======================

This article explains the user-visible changes in kwant 0.3.


``possible_hoppings`` replaced by `~kwant.builder.HoppingKind`
--------------------------------------------------------------
The `~kwant.builder.Builder` method ``possible_hoppings`` has been rendered
obsolete.  Where previously one would have had ::

    for kind in lat.nearest:
        sys[sys.possible_hoppings(*kind)] = t

now it suffices to write ::

    sys[lat.nearest] = t

This is possible because `~kwant.builder.Builder` now accepts *functions* as
keys in addition to `~kwant.builder.Site` objects and tuples of them
(hoppings).  These functions are expected to yield either sites or hoppings,
when given a builder instance as the sole argument. The use of such keys is to
implement sets of sites or hoppings that depend on what is already present in
the builder, such as `~kwant.builder.HoppingKind`.  In the above example,
``lat.nearest`` is a list of ``HoppingKind`` objects.

Some renames
------------
* site groups are now called site families.  This affects all the names that
  used to contain "group" or "groups".
* ``wave_func`` has been renamed to `~kwant.solvers.default.wave_function`,
* ``MonatomicLattice`` has been renamed to `~kwant.lattice.Monatomic`,
* ``PolyatomicLattice`` has been renamed to `~kwant.lattice.Polyatomic`.

Band structure plots
--------------------
A convenience function `~kwant.plotter.bands` for quick plotting of band
structure was implemented.

Immutable site families
-----------------------
In order to make naming more consistent, `kwant.make_lattice` was renamed and
can be found now as `~kwant.lattice.general`. Classes `Chain`, `Square`, and
`Honeycomb` from `~kwant.lattice` were made functions `~kwant.lattice.chain`,
`~kwant.lattice.square`, and `~kwant.lattice.honeycomb`.

In previous versions if one executed `a = kwant.lattice.square();
b = kwant.lattice.square()` then `a` and `b` were
actually different lattices. This often led to confusions in more convoluted
use cases, so this behavior was changed. Now two site families created with the
same parameters are actually indistinguishable by `kwant`. If it is desired to
make two site families which have the same geometry, but mean different things,
as for instance in :doc:`../tutorial/tutorial5`, then the `name` argument has
to be used when creating a lattice, e.g. `a = kwant.lattice.square(name='a');
b = kwant.lattice.square(name='b')`.

Parameters to Hamiltonian
-------------------------
kwant now allows the Hamiltonian matrix elements to be described with functions
that depend on an arbitrary number of parameters in addition to the sites on
which they are defined.

Previously, functions defining the Hamiltonian matrix elements had to have the
following prototypes::

    def onsite(site):
        ...

    def hopping(site1, site2):
        ...

If the Hamiltonian elements need to depend on some other external parameters
(e.g. magnetic field) then those had to be provided by some other means than
regular function parameters (e.g. global variables).

Now the value functions may accept arbitrary arguments after the `Site`
arguments.  These extra arguments can be specified when
`~kwant.solvers.default.solve` is called by setting the arguments:

args
    A tuple of values to be passed as the positional arguments to the
    Hamiltonian value functions (not including the `Site` arguments).

For example, if the hopping and onsite Hamiltonian value functions have
the following prototype::

    def onsite(site, t, B, pot):
        ...

    def hopping(site1, site2, t, B, pot):
        ...

then the values of `t`, `B` and `pot` for which to solve the system can be
passed to `solve` like this::

    kwant.solve(sys, energy,
                args=(2., 3., 4.))

A more verbose way to do the same is to pass to the functions an object,
containing all the parameters as attributes::

    class SimpleNamespace(object):
        def __init__(self, **kwargs):
            self.__dict__.update(kwargs)
    # With Python >= 3.3 we can have instead:
    # from types import SimpleNamespace

    params = SimpleNamespace()

    def onsite(site, p):
        mu = p.mu
        ...

    def hopping(site1, site2, p):
        t, B = p.t, p.B
        ...

    kwant.solve(sys, energy,
                args=(params(t=1., mu=2., B=0.1))

Arguments can be passed in an equivalent way in calls to
`~kwant.solvers.default.wave_function` and `~kwant.solvers.default.ldos`.

Change of modes format and `~kwant.builder.ModesLead`
-----------------------------------------------------
The return format of the modes calculation was simplified, and so was
the information required by the solvers about the leads.

`~kwant.physics.selfenergy` now uses the output of `~kwant.physics.modes` as
input instead of the slice Hamiltonian and inter-slice hopping.

Similar to self-energy, calculation of modes is now the lead's responsibility.
There is also a new object `~kwant.builder.ModesLead`, allowing to attach leads
that have a custom way of calculating their modes, e.g. ideal leads.
