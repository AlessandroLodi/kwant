What's New in kwant 0.3
=======================

This article explains the user-visible changes in kwant 0.3.


``possible_hoppings`` replaced by `~kwant.builder.HoppingKind`
--------------------------------------------------------------
The `~kwant.builder.Builder` method ``possible_hoppings`` has been rendered
obsolete.  Where previously one would have had ::

    for kind in lat.nearest:
        sys[sys.possible_hoppings(*kind)] = t

now it suffices to write ::

    sys[lat.neighbors()] = t

This is possible because `~kwant.builder.Builder` now accepts *functions* as
keys in addition to `~kwant.builder.Site` objects and tuples of them
(hoppings).  These functions are expected to yield either sites or hoppings,
when given a builder instance as the sole argument. The use of such keys is to
implement sets of sites or hoppings that depend on what is already present in
the builder, such as `~kwant.builder.HoppingKind`.  In the above example,
``lat.nearest`` is a list of ``HoppingKind`` objects.

Some renames
------------
* site groups are now called site families.  This affects all the names that
  used to contain "group" or "groups".
* ``wave_func`` has been renamed to `~kwant.solvers.default.wave_function`,
* ``MonatomicLattice`` has been renamed to `~kwant.lattice.Monatomic`,
* ``PolyatomicLattice`` has been renamed to `~kwant.lattice.Polyatomic`.

Band structure plots
--------------------
A convenience function `~kwant.plotter.bands` for quick plotting of band
structure was implemented.

Immutable site families
-----------------------
In order to make naming more consistent, `kwant.make_lattice` was renamed and
can be found now as `~kwant.lattice.general`. Classes `Chain`, `Square`, and
`Honeycomb` from `~kwant.lattice` were made functions `~kwant.lattice.chain`,
`~kwant.lattice.square`, and `~kwant.lattice.honeycomb`.

In previous versions if one executed `a = kwant.lattice.square();
b = kwant.lattice.square()` then `a` and `b` were
actually different lattices. This often led to confusions in more convoluted
use cases, so this behavior was changed. Now two site families created with the
same parameters are actually indistinguishable by `kwant`. If it is desired to
make two site families which have the same geometry, but mean different things,
as for instance in :doc:`../tutorial/tutorial5`, then the `name` argument has
to be used when creating a lattice, e.g. `a = kwant.lattice.square(name='a');
b = kwant.lattice.square(name='b')`.

Parameters to Hamiltonian
-------------------------
kwant now allows the Hamiltonian matrix elements to be described with functions
that depend on an arbitrary number of parameters in addition to the sites on
which they are defined.

Previously, functions defining the Hamiltonian matrix elements had to have the
following prototypes::

    def onsite(site):
        ...

    def hopping(site1, site2):
        ...

If the Hamiltonian elements need to depend on some other external parameters
(e.g. magnetic field) then those had to be provided by some other means than
regular function parameters (e.g. global variables).

Now the value functions may accept arbitrary arguments after the `Site`
arguments.  These extra arguments can be specified when
`~kwant.solvers.default.solve` is called by setting the arguments:

args
    A tuple of values to be passed as the positional arguments to the
    Hamiltonian value functions (not including the `Site` arguments).

For example, if the hopping and onsite Hamiltonian value functions have
the following prototype::

    def onsite(site, t, B, pot):
        ...

    def hopping(site1, site2, t, B, pot):
        ...

then the values of `t`, `B` and `pot` for which to solve the system can be
passed to `solve` like this::

    kwant.solve(sys, energy,
                args=(2., 3., 4.))

With many parameters it can be less error-prone to collect all of them into a
single object and pass this object as the single argument.  Such a parameter
collection could be a dictionary, or a class instance, for example::

    class SimpleNamespace(object):
        def __init__(self, **kwargs):
            self.__dict__.update(kwargs)
    # With Python >= 3.3 we can have instead:
    # from types import SimpleNamespace

    def onsite(site, p):
        return p.mu * ...

    def hopping(site1, site2, p):
        return p.t * exp(-1j * p.B * ...)

    params = SimpleNamespace(t=1, mu=2)
    for params.B in B_values:
        kwant.solve(sys, energy, args=[params])

Arguments can be passed in an equivalent way to
`~kwant.solvers.default.wave_function`,
`~kwant.system.System.hamiltonian_submatrix`, etc.

Lattice and shape improvements
------------------------------
`~kwant.lattice.Monoatomic.closest` now returns an exact, and not approximately
closest point. A new method `~kwant.lattice.Monoatomic.n_closest` was added,
which returns n closest lattice points.

Likewise `~kwant.lattice.Polyatomic.shape` has acquired an improved flood-fill
algorithm, making it work better on narrow ribbon (which were sometimes buggy
before with non-square lattices). Additionally, it was made symmetry-aware, so
if a shape is used for a lead, no conditions with regard to coordnate parallel
to the lead period are required.

Finally, lattices now have a method `~kwant.lattice.Polyatomic.neighbors`,
which calculates all the n-th shortest possible hoppings on this lattice.
