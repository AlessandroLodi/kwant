Roughly in order of importance.                                     -*-org-*-

* Define a few benchmarks and check performance.  Optimize the code.

* Write a fast tiny array module.
  This should speed up many operations in kwant.

* Take care of mutable default arguments (mostly in plotter)
  This should also allow to solve the problem with unreadable function
  prototypes in the documentation.

* Allow plotting of finalized infinite systems.

* Enhance the line argument of kwant.plotter.plot
  It could understand "hopping kinds" in the same way possible_hoppings does.

* Provide nice support for graphene double layers
  This could be done by allowing lattices to be shifted, or in some other way.

* Wrap mumps, umfpack, or some other sparse linear algebra library with Cython.
  Use it directly in sparse solver.  This will allow to fine-tune the solution
  of sparse systems.

* Benchmark mumps and check whether nested dissection would be useful.
  If yes, implement it.

* Use sparse linear algebra to calculate bands
  However, scipy's sparse eigenvalues don't seem to work well.

* Show plotting of functions of system in the tutorial.

* Allow easy plotting of functions into files on disk.

* Allow attaching leads with further than nearest slice hoppings.
  The most easy way to do this is increasing the period of the lead.
  Alternatively, generalize modes and InfiniteSystem format.

* Optionally show site coordinates when plotting a system.

* Add support for easily adding magnetic field to a system.

* Generalize InfiniteSystem to multiple directions.

* Add support for optimization of lead fundamental domains.

* Write a module to generate "functional" random numbers.
  This is a good starting point:
  http://www.cs.umbc.edu/~olano/papers/GPUTEA.pdf

* Incorprorate efficient correlated disorder using scipy.spatial.

* Write an RGF/SM solver which uses graph/slicer.

* Implement the C solver interface.

* Wrap TB_SIM as a solver.

* Implement time domain propagation solver, or coordinate with Kruckl, who
  wanted to implement it.

* Implement models module, incorporate units into it.

* Improve handling of s-matrices with important additional degrees of freedom.
  i.e. spin, or electron-hole.  Currently, one needs to manually process lead
  modes and to perform a basis transformation of the scattering matrix.

* Implement automatic search for discrete symmetries of a tight binding model
  and of conservation laws.

* Revisit Symmetry, make it more general. I.e. allow for description of other
  discrete symmetries, possibly also symmetries which change site and hopping
  values (=gauge symmetries).

* It would be nice to have interactive plots of (3d) systems.
  Perhaps the right way to achieve this is by using matplotlib.
