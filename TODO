Roughly in order of importance.                                     -*-org-*-

* Document the order of sites/orbitals in finalized builders

* Make kwant run on windows

* Add calculation of current density

* Consider making the b parameter of _solve_linear_sys a matrix instead of a
  list of matrices

* Implement "inhomogeneous arrays" for ldos and wavefunc
  The point is to have ldos or wavefunc return objects that behave like 2d
  arrays, where the site index and orbital index are separate.  However, this
  must work in the general case where the number of orbitals per site varies.

* Go through the documentation and apply consistent linking/naming practice:
  We could adopt the scheme that is used in Python's stdlib.  See for example
  http://docs.python.org/2/library/threading.html
  This would mean:
  - When referring to functions, we always append "()" to their name.
  - Names of objects (types, functions, ...) that are a documented part of
    kwant are always hyperlinks _when_ the object itself is meant.
  - Concepts that are meant in a more general sense are not hyperlinked, even if
    there exists an object of the same name in kwant.  (Consider the usage of
    linking for the term "Thread" in the document linked above.)

* Plotter: show site upon click

* fix physics.noise (docstring, __all__, etc.)

* Verify that selective plotting works.

* Write an RGF solver that uses graph/slicer.

* Add support for easily adding magnetic field to a system.

* Allow plotting of infinite systems

* Use sparse linear algebra to calculate bands
  However, SciPy's sparse eigenvalues don't seem to work well.

* Allow attaching leads with further than nearest slice hoppings.
  The most easy way to do this is increasing the period of the lead.
  Alternatively, generalize modes and InfiniteSystem format.

* Benchmark MUMPS and check whether nested dissection would be useful.
  If yes, implement it.

* Make kwant objects pickleable.

* "shape" doesn't work for leads when only checking 'y' (and not 'x')
  Make it aware of symmetries.

* Improve experience when working with sites in a finalized builder
  (It should be possible to map sites to nodes efficiently.  Probably, the best
  way to do it is to sort the sites in finalized builders.)
  One could then also RLE compress sites in finalized builders.

* In finalized leads, only keep the sites of the slice.

* Generalize InfiniteSystem to multiple directions.

* Add support for optimization of lead fundamental domains.

* Incorprorate efficient correlated disorder using scipy.spatial.

* Implement the C solver interface.

* Wrap TB_SIM as a solver.

* Implement models module, incorporate units into it.

* Improve handling of s-matrices with important additional degrees of freedom.
  i.e. spin, or electron-hole.  Currently, one needs to manually process lead
  modes and to perform a basis transformation of the scattering matrix.

* Implement automatic search for discrete symmetries of a tight binding model
  and of conservation laws.

* Revisit Symmetry, make it more general. I.e. allow for description of other
  discrete symmetries, possibly also symmetries which change site and hopping
  values (=gauge symmetries).

* Make an option for plotting hoppings as arcs, in order for overlapping
  hoppings to be distinguishable. Also potentially add arrows to the hoppings.

* Adopt mincut/maxflow algorithm from networkx or python-graph to find the best
  representation of a lead unit cell.

* Make shape a callable that uses system symmetry.
  Similarly to HoppingKind, which requires information about sites in the
  builder to generate hoppings, shape can be made symmetry-aware.

* Consider using two-way-compressed uni-directional graphs in systems
  advantages:
  - The number of edges gets reduced by 1/2.
  - The Hermicity of the Hamiltonian is enforced in a more obvious way.
  - It's clear at system level which Hamiltonian elements are defined
    directly.
  Would Michael's graph slicing code continue to work?

* Speed up kwant.contrib.digest
  by using SipHash and Ziggurat algorithm in C/Cython

* Add a test of kwant that verifies QHE conductance quantization
